# -*- coding: utf-8 -*-
"""[TEST] load parameter from saved model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AJPktrR9uKTd4LACO344oQnpt4b4yHBh
"""

!pip install torch torchvision torchmetrics

from google.colab import drive
drive.mount('/content/drive')

# Import required libraries
# -------------------------
# Data loading
import random
import numpy as np
from torchvision.transforms import transforms
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader
from torch.utils.data import random_split, DataLoader
import matplotlib.pyplot as plt
import torch
from torchvision import models
import torch.nn as nn
import torch.optim as optim
from torchmetrics import  Accuracy, F1Score, Recall
from torchvision import models
# Set random seeds for reproducibility
torch.manual_seed(101010)
np.random.seed(101010)
random.seed(101010)

# 1. Load the pre-trained model
model = models.resnet18(pretrained=True)

# 2. Modify the final layer as did in previous model
fc_in_features = model.fc.in_features
model.fc = nn.Linear(fc_in_features, 1, bias=True)

# Load the parameters of the final layer if you've saved them
final_layer_params = torch.load("/content/drive/MyDrive/Colab Notebooks/CNN-Chest_X_Ray/20241103_finetune_LastLayerParameters.pth")
model.fc.load_state_dict(final_layer_params)

# 3. Prepare the dataset (replace with your dataset path and transformations)
transform_mean = [0.485, 0.456, 0.406]
transform_std =[0.229, 0.224, 0.225]
train_transform = transforms.Compose([transforms.ToTensor(),
                                transforms.RandomRotation((0,30)),
                                transforms.RandomHorizontalFlip(),
                                transforms.Normalize(mean=transform_mean, std=transform_std)])

val_test_transform = transforms.Compose([transforms.ToTensor(),
                                transforms.Normalize(mean=transform_mean, std=transform_std)])

# Apply the image transforms
train_dataset = ImageFolder("/content/drive/MyDrive/Colab Notebooks/CNN-Chest_X_Ray/data/chestxrays/train", transform=train_transform)
test_dataset = ImageFolder('/content/drive/MyDrive/Colab Notebooks/CNN-Chest_X_Ray/data/chestxrays/test', transform=val_test_transform)

# Create Validation Dataset
train_size = int(0.8 * len(train_dataset)) # 80% for training
val_size = len(train_dataset) - train_size # 20% for validation
train_dataset, val_dataset = random_split(train_dataset, [train_size, val_size])

# Update transformation for validation sets.
val_dataset.dataset.transform = val_test_transform

# Create data loaders
train_loader = DataLoader(train_dataset, batch_size=len(train_dataset) // 2, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=len(test_dataset))
val_loader = DataLoader(val_dataset, batch_size = len(val_dataset))

# 4. Define the evaluation function
def evaluate_model(model, data_loader):
    model.eval()  # Set the model to evaluation mode

    # Initialize metrics
    accuracy_metric = Accuracy(task="binary")
    recall_metric = Recall(task="binary")
    f1_metric = F1Score(task="binary")

    # Create lists to store all predictions and labels
    all_preds = []
    all_labels = []

    # Disable gradient calculation for evaluation
    with torch.no_grad():
        for inputs, labels in data_loader:
            outputs = model(inputs)
            preds = torch.sigmoid(outputs).round()  # Round to 0 or 1

            # Extend the lists with predictions and labels
            all_preds.extend(preds.tolist())
            all_labels.extend(labels.tolist())

    # Convert lists back to tensors after the loop
    all_preds = torch.tensor(all_preds)
    all_labels = torch.tensor(all_labels).view(-1,1)

    # Calculate performance metrics
    val_acc = accuracy_metric(all_preds, all_labels).item()
    val_recall = recall_metric(all_preds, all_labels).item()
    val_f1 = f1_metric(all_preds, all_labels).item()

    # Return the metrics
    return val_acc, val_recall, val_f1

# Evaluate on validation set.
val_accuracy, val_recall, val_f1 = evaluate_model(model, val_loader)
print(f'Validation Accuracy: {val_accuracy:.4f}')
print(f'Validation Recall: {val_recall:.4f}')
print(f'Validation F1 Score: {val_f1:.4f}')